  var _isSaying = false;
  var _isHidden = true;

  double _getImageHeight() {
    if (widget.step.description.length >= 140) {
      return Util.pageHeight(context) * RecipeStepWidget._imageSize * 0.9;
    }
    return Util.pageHeight(context) * RecipeStepWidget._imageSize;
  }

  Widget _buildFlipAnimation() {
    return GestureDetector(
      onTap: () => setState(() => _isHidden = !_isHidden),
      child: AnimatedSwitcher(
        duration: const Duration(milliseconds: 600),
        child: _isHidden ? _buildShortTimer() : _buildLongTimer(),
      ),
    );
  }

  Widget _buildShortTimer() {
    return Container(
      width: 70,
      height: 70,
      margin: const EdgeInsets.fromLTRB(0, 70, 0, 0),
      decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.horizontal(right: Radius.circular(20))),
      alignment: Alignment.center,
      child: const Icon(
        Icons.timer,
        color: Colors.black87,
        size: 30,
      ),
    );
  }

  Widget _buildLongTimer() {
    return Row(
      children: [
        Container(
          height: 70,
          width: 70 * 3,
          margin: const EdgeInsets.fromLTRB(0, 70, 0, 0),
          color: Colors.white,
        ),
        Container(
          width: 70,
          height: 70,
          margin: const EdgeInsets.fromLTRB(0, 70, 0, 0),
          decoration: const BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.horizontal(right: Radius.circular(20))),
          alignment: Alignment.center,
          child: const Icon(
            Icons.timer,
            color: Colors.black87,
            size: 30,
          ),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isSaying) {
      widget.onSayButton();
    }
    return Stack(children: [
      Container(
          padding: const EdgeInsets.all(Util.padding),
          child: Column(
            children: [
              HeaderPanel.buildButton(context, _buildSayIcon(),
                  !_isSaying ? Colors.white : Colors.white54),
              Container(
                margin: const EdgeInsets.fromLTRB(0, Util.margin, 0, 0),
                height: _getImageHeight(),
                child: ClipRRect(
                  borderRadius:
                      BorderRadius.circular(RecipeStepWidget._borderRadius),
                  child: Image(
                    image: AssetImage(widget.step.imgUrl),
                    fit: BoxFit.fitHeight,
                  ),
                ),
              ),
              Container(
                  alignment: Alignment.topCenter,
                  margin: const EdgeInsets.symmetric(
                      vertical: Util.margin, horizontal: 0),
                  child: Container(
                    decoration: BoxDecoration(
                        color: Colors.black87.withOpacity(
                            RecipeStepWidget._textBackgroundOpacity),
                        borderRadius: BorderRadius.circular(
                            RecipeStepWidget._borderRadius)),
                    // height: 120,
                    alignment: Alignment.center,
                    padding: const EdgeInsets.all(Util.padding),
                    child: Text(
                      widget.step.description,
                      style: TextStyle(
                          fontFamily: "Montserrat",
                          fontSize: Util.pageHeight(context) *
                              RecipeStepWidget._textSize,
                          color: Colors.white),
                    ),
                  )),
            ],
          )),
      _buildFlipAnimation()
    ]);
  }

  IconButton _buildSayIcon() {
    return IconButton(
        onPressed: () {
          setState(() {
            _isSaying = !_isSaying;
          });
          if (_isSaying) {
            widget.onSayButton();
          } else {
            widget.onStopButton();
          }
        },
        icon: _isSaying
            ? const Icon(
                Icons.pause,
                color: Colors.black87,
              )
            : const Icon(
                Icons.play_arrow,
                color: Colors.black87,
              ));
  }

  Widget _buildFlipAnimation() {
    return GestureDetector(
      onTap: () => setState(() => _isHidden = !_isHidden),
      child: AnimatedSwitcher(
        duration: const Duration(milliseconds: 600),
        child: _isHidden ? _buildShortTimer() : _buildLongTimer(),
      ),
    );
  }

  Widget _buildShortTimer() {
    return Container(
      width: 70,
      height: 70,
      margin: const EdgeInsets.fromLTRB(0, 70, 0, 0),
      decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.horizontal(right: Radius.circular(20))),
      alignment: Alignment.center,
      child: const Icon(
        Icons.timer,
        color: Colors.black87,
        size: 30,
      ),
    );
  }

  Widget _buildLongTimer() {
    return Row(
      children: [
        Container(
          height: 70,
          width: 70 * 3,
          margin: const EdgeInsets.fromLTRB(0, 70, 0, 0),
          color: Colors.white,
        ),
        Container(
          width: 70,
          height: 70,
          margin: const EdgeInsets.fromLTRB(0, 70, 0, 0),
          decoration: const BoxDecoration(
              color: Colors.white,
              borderRadius:
                  BorderRadius.horizontal(right: Radius.circular(20))),
          alignment: Alignment.center,
          child: const Icon(
            Icons.timer,
            color: Colors.black87,
            size: 30,
          ),
        ),
      ],
    );
  }

            Container(
              padding: const EdgeInsets.all(Util.padding),
              child: Icon(
                Icons.timer_outlined,
                color: Colors.black87,
                size: _iconHeight * Util.pageHeight(context),
              ),
            ),

import 'dart:async';

import 'package:flutter/material.dart';

import 'package:voice_recipe/components/util.dart';

class TimerInfo {
  Duration? leftDuration;
  bool? wasDisposed;
  bool? isActive;
  Timer? timer;

  TimerInfo(this.leftDuration, this.isActive, this.wasDisposed, [this.timer]);
}

class CookTimer extends StatefulWidget {
  CookTimer({super.key, required this.slideId, required this.waitTimeMins}) {
    debugPrint('CookTimer created!');
  }

  final int slideId;
  final int waitTimeMins;
  final Map<int, TimerInfo> timersMap = {};

  @override
  State<CookTimer> createState() => _CookTimerState();
}

class _CookTimerState extends State<CookTimer> {
  static const _height = 0.1;
  static const _iconHeight = 0.1 * 0.6;
  Duration? leftDuration;
  bool wasDisposed = false;
  bool isActive = false;
  Timer? timer;

  @override
  void initState() {
    super.initState();
    if (!widget.timersMap.containsKey(widget.slideId)) {
      widget.timersMap[widget.slideId] = TimerInfo(Duration(minutes: widget.waitTimeMins),
          false, false);
    }
    var info = widget.timersMap[widget.slideId];
    leftDuration = info!.leftDuration;
    wasDisposed = info.wasDisposed!;
    isActive = info.isActive!;
    timer = info.timer;
    leftDuration ??= Duration(minutes: widget.waitTimeMins);
    if (wasDisposed && isActive) {
      timer?.cancel();
      startTimer();
    }
    wasDisposed = false;
  }

  @override
  void dispose() {
    super.dispose();
    widget.timersMap[widget.slideId] = TimerInfo(leftDuration, isActive, wasDisposed, timer);
  }

  void startTimer() {
    isActive = true;
    timer = Timer.periodic(const Duration(seconds: 1), (_) => setCountDown());
  }

  void stopTimer() {
    isActive = false;
    setState(() => timer?.cancel());
  }

  void resetTimer() {
    stopTimer();
    setState(() => leftDuration = Duration(minutes: widget.waitTimeMins));
  }

  void setCountDown() {
    const reduceSecondsBy = 1;
    final seconds =  leftDuration!.inSeconds - reduceSecondsBy;
    debugPrint('TICK $seconds');
    if (seconds < 0) {
      timer!.cancel();
    } else {
      leftDuration = Duration(seconds: seconds);
    }
    if (!wasDisposed) {
      setState(() {
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(Util.borderRadiusLarge)),
      height: Util.pageHeight(context) * _height,
      margin: const EdgeInsets.fromLTRB(0, Util.margin, 0, 0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: [
          timerButton(onPressed: () {
            setState(() {
              isActive = !isActive;
            });
            if (isActive) {
              startTimer();
            } else {
              stopTimer();
            }
          }, icon: Icon(
            isActive ? Icons.pause_circle : Icons.play_circle,
            color: Colors.black87.withOpacity(0.8),
          )),
          timeLabel(),
          timerButton(onPressed: () {
            setState(() {
              resetTimer();
            });
          }, icon: Icon(
            Icons.replay_circle_filled_rounded,
            color: Colors.black87.withOpacity(0.8),
          ))
        ],
      ),
    );
  }

  Widget timerButton({required void Function() onPressed, required Icon icon}) {
    return Container(
      padding: const EdgeInsets.all(Util.padding),
      child: IconButton(
          onPressed: onPressed,
          iconSize: _iconHeight * Util.pageHeight(context),
          icon: icon),
    );
  }

  Widget timeLabel() {
    const labelWidth = 0.3;
    const fontSize = 0.05;
    String strDigits(int n) => n.toString().padLeft(2, '0');
    leftDuration ??= Duration(minutes: widget.waitTimeMins);
    final hours = strDigits( leftDuration!.inHours.remainder(24));
    final minutes = strDigits( leftDuration!.inMinutes.remainder(60));
    final seconds = strDigits( leftDuration!.inSeconds.remainder(60));
    return Container(
      alignment: Alignment.center,
      width: labelWidth * Util.pageWidth(context),
      child: Text(
        leftDuration!.inHours == 0
            ? "$minutes:$seconds"
            : "$hours:$minutes:$seconds",
        style: TextStyle(
            fontFamily: "Montserrat",
            fontSize: fontSize * Util.pageHeight(context),
            color: Colors.black87),
      ),
    );
  }
}
